# Refactoring: Improving the Design of Existing Code

- [ ] Refactoring: A First Example
  - [x] The Starting Point
  - [x] Comments on the Starting Program
  - [x] The First Step in Refactoring
  - [ ] Decomposing the statement Function
  - [ ] Status: Lots of Nested Functions
  - [ ] Splitting the Phases of Calculation and Formatting
  - [ ] Status: Separated into Two Files (and Phases)
  - [ ] Reorganizing the Calculations by Type
  - [ ] Status: Creating the Data with the Polymorphic Calculator
  - [ ] Final Thoughts
- [ ] Principles in Refactoring
  - [ ] Defining Refactoring
  - [ ] The Two Hats
  - [ ] Why Should We Refactor?
  - [ ] When Should We Refactor?
  - [ ] Problems with Refactoring
  - [ ] Refactoring, Architecture, and Yagni
  - [ ] Refactoring and the Wider Software Development Process
  - [ ] Refactoring and Performance
  - [ ] Where Did Refactoring Come From?
  - [ ] Automated Refactorings
  - [ ] Going Further
- [ ] Bad Smells in Code
- [ ] Building Tests
- [ ] Introducing the Catalog
- [ ] A First Set of Refactorings
- [ ] Encapsulation
- [ ] Moving Features
- [ ] Organizing Data
- [ ] Simplifying Conditional Logic
- [ ] Refactoring APIs
- [ ] Dealing with Inheritance


A book by Martin Fowler
